### ActiveMQ

通信方式：

1. 点对点通信
2. 广播式通信

应用场景：

1. 系统间解耦
2. 异步通信：一般要求每个请求的处理在200ms内完成，对用户来说几乎是无感觉的。
3. 流量削峰：一般情况下mysql每秒请求2k个还好。

可能存在的问题：  

1. 消息重复发送
2. 服务挂了
3. 高可用问题
4. 消费的可靠性传输
   	* 消息生产者端
      	* 消息队列中间件端
         	* 消息消费者端

解决办法：  

1. 消息重复发送，增加消息状态表，为每一个消息增加一个状态。当有两条重复的消息，就不发送。
2. 服务如果挂了，那么会有一个问题是，非持久化的消息在重启后就没了，因为它们都是存储在内存中。而持久化的消息则会永久存在。
3. 高可用可以采取集群方式，activemq使用主从方式。类似与zookeeper。 
4. 在消息的生产者端使用confirm方式，如果使用事务方式向mq发送消息，需要考虑的是同步问题，也就是说事务的方式它是阻塞式的。在mq端可以采取持久化的方式，将消息持久化到硬盘中。消息消费者端可以采取手动确认的方式，因为默认的情况下mq是自动确认方式。

持久化方式：

可以通过修改conf/activemq.xml文件来指定持久化方式。

1. KahaDB存储（默认方式）：所有的消息顺序添加到一个日志文件中，同时有一个索引文件记录了指向这些日志的存储地址，还有一个事务日志用于消息回复操作。  
   * db.data文件：消息的索引文件，它的数据结构是B-Tree，使用B-Tree作为索引指向db-*.log文件里的存储的消息。
   * db-*.log文件：存储具体的消息记录。消息顺序写入，因此消息存储较快。默认是32M，到达阀值会自动扩容。
   * db.redo文件：用于消息的恢复。
   * lock文件锁：写入当前获得读写权限的broker。用于在集群情况下的竞争问题。
2. JDBC存储：使用JDBC方式，默认会创建3张表。
   * activemq_msgs:存放具体的消息。
   * activemq_acks:存储持久订阅的消息和最后一个持久订阅接收的消息ID。
   * acitvemq_lock:保证在某一时刻只有一个broker访问数据库。
3. LevelDB存储：持久化性能高于KahaDB。官方建议使用，但不再支持。
4. JDBC Message store with ActiveMQ Journal:使用延迟存储数据到数据库，当消息来时，先存放到临时文件中。然后再持久化到数据库中。当消费者的消费的速度能够及时跟上生产者的生产速度时（也就是说需要持久化到数据库中的数据很少），这种方式就有很大优势。

堆积能力：



投递方式：

